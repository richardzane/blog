(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{679:function(t,e,a){"use strict";a.r(e);var s=a(17),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue-中的-data-为什么是一个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的-data-为什么是一个函数"}},[t._v("#")]),t._v(" vue 中的 data 为什么是一个函数")]),t._v(" "),a("p",[t._v("参考文章：")]),t._v(" "),a("p",[t._v("https://www.cnblogs.com/zwn-lucky7/p/15534366.html")]),t._v(" "),a("p",[t._v("答案概述：")]),t._v(" "),a("p",[t._v("因为一个 vue 组件经过封装之后，可以被用来创建多个实例，如果组件中的这个 data 是一个纯粹的对象，那么所有的组件实例都会共享引用这个数据对象，造成数据污染的问题。所以 data 被设计成是一个函数，用来返回一个全新的副本对象实例。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"v-model-双向绑定原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-model-双向绑定原理"}},[t._v("#")]),t._v(" v-model 双向绑定原理")]),t._v(" "),a("p",[t._v("参考文章：")]),t._v(" "),a("ul",[a("li",[t._v("https://juejin.cn/post/6844903903822086151")]),t._v(" "),a("li",[t._v("https://juejin.cn/post/6844903479044112391")]),t._v(" "),a("li",[t._v("https://juejin.cn/post/6844904015516401678")])]),t._v(" "),a("p",[t._v("总结：")]),t._v(" "),a("ul",[a("li",[t._v("mvvm 数据双向绑定：数据变化更新视图，视图变化更新数据；")]),t._v(" "),a("li",[t._v("vue 是采用数据劫持结合发布者-订阅者模式的方法，通过 Object.defineProperty() 来劫持各个属性的 get() 和 set() ，在数据变动时发布消息给订阅者，执行响应的监听回调函数。")]),t._v(" "),a("li",[t._v("它主要的步骤包括：")]),t._v(" "),a("li",[t._v("实现一个监听器 Observer，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；")]),t._v(" "),a("li",[t._v("实现一个订阅器 Dep，用来收集订阅者，对监听器 Observer 和 订阅者 Watcher 进行统一管理；")]),t._v(" "),a("li",[t._v("实现一个订阅者 Watcher，可以收到属性的变化的通知，并执行相应的方法，从而更新视图；")]),t._v(" "),a("li",[t._v("实现一个解析器 Compile，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。")])]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("p",[t._v("一、参考文章：")]),t._v(" "),a("ul",[a("li",[t._v("https://www.cnblogs.com/jjgw/p/12111517.html")])]),t._v(" "),a("p",[t._v("一、vue 实例从开始创建、初始化数据、编译模板、挂载、更新到销毁的一系列过程，叫做 vue 的生命周期。")]),t._v(" "),a("p",[t._v("二、vue 所有功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和 DOM 渲染两大功能。")]),t._v(" "),a("p",[t._v("三、vue 生命周期的钩子函数主要包括四大类，分别是创建类、挂载类、更新类、销毁类。")]),t._v(" "),a("ul",[a("li",[t._v("beforeCreate 创建前：此时数据还没有初始化。可以在这个阶段打开 loading 。")]),t._v(" "),a("li",[t._v("created 创建后：此时已经初始化了数据，因此能够访问 data、computed 等属性。可以在这个阶段发送异步请求，关闭 loading。")]),t._v(" "),a("li",[t._v("beforeMount 挂载前：此时根节点已经创建了，但是还没挂载。")]),t._v(" "),a("li",[t._v("mounted 挂载后：此时已经挂载了根节点，数据双向绑定。可以在这个阶段获取 dom 节点进行操作，也可以发送异步请求，但是有可能造成页面闪屏问题。")]),t._v(" "),a("li",[t._v("beforeUpdate 更新前：可以在这个阶段添加或者删除事件监听器。")]),t._v(" "),a("li",[t._v("update：更新后：可以在这个阶段拿到更新后的 dom 节点。")]),t._v(" "),a("li",[t._v("beforeDestroy 销毁前：可以在这个阶段清除之前设置的定时器。")]),t._v(" "),a("li",[t._v("destroyed 销毁后：此时组件已经被销毁了，不能在这个阶段执行任何操作。")])]),t._v(" "),a("p",[t._v("四、首次进入 vue 组件，会依次执行 beforeCreate 、created 、beforeMount 和 mounted 等钩子函数。")]),t._v(" "),a("p",[t._v("五、如果父组件存在子组件，进入父组件时，首先执行父组件的 beforeCreate、created 、beforeMount 函数，接着执行子组件一的 beforeCreate、created、beforeMount 函数，接着执行子组件二的 beforeCreate、created、beforeMount 函数，然后依次执行子组件一的 mounted 函数、子组件二的 mounted 函数，最后才执行父组件的 mounted 函数。离开父组件时，首先执行父组件的 beforeDestroy 函数，接着执行子组件一的 beforeDestroy、destroryed 函数，然后执行子组件二的 beforeDestroy、destroryed 函数，最后才执行父组件的 destroyed 函数。")]),t._v(" "),a("p",[t._v("六、如果使用了 vue 自带的 keep-alive 组件，会多出两个钩子函数，activated 和 deactivated 。第一次进入到缓存的组件，将会依次执行 beforeCreate、created 、beforeMount 、mounted 和 activated 钩子函数。以后再次进入，只会执行 activated 钩子函数。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[t._v("#")]),t._v(" Keep-alive")]),t._v(" "),a("p",[t._v("一、（作用介绍）keep-alive 是 vue 自带的一个组件，用来缓存其他组件，以此提高性能。")]),t._v(" "),a("p",[t._v("二、（使用场景）可以用于缓存商品详情页面。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("{\n\tname: 'View1',\n\tmeta: {\n\t\tisKeepAlive: true\n\t},\n\tpath: '/view1',\n\t...\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<keep-alive v-if="$route.meta.isKeepAlive">\n\t<router-view></router-view>\n</keep-alive>\n<router-view v-if="!$route.meta.isKeepAlive"></router-view>\n')])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"v-if-和-v-show-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-的区别"}},[t._v("#")]),t._v(" v-if 和 v-show 的区别")]),t._v(" "),a("p",[t._v("一、（作用介绍）v-if 和 v-show 都可以用来显示和隐藏元素，它们的具体区别如下：")]),t._v(" "),a("p",[t._v("二、（原理不同）v-if 显示和隐藏元素是通过创建和删除 dom 节点实现的，v-show 则是通过设置 display 的值实现的。")]),t._v(" "),a("p",[t._v("三、（开销不同）如果是首次加载并且隐藏元素，v-if 不会创建 dom 节点，v-show 会创建 dom 节点并将 display 的值设置为 none，所以此时 v-if 的开销比 v-show 小。如果是显示和隐藏元素来回切换，v-if 会频繁创建和删除 dom 节点，v-show 只是修改一下 display 的值，此时 v-if 的开销比 v-show 大。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"v-for-和-v-if-的优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-for-和-v-if-的优先级"}},[t._v("#")]),t._v(" v-for 和 v-if 的优先级")]),t._v(" "),a("p",[t._v("v-for 的优先级大于 v-if ，这是在 vue 的源码中的 genElement 函数规定的。一般不建议将 v-for 和 v-if 同时写在一个元素上面，程序会报错。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"ref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[t._v("#")]),t._v(" ref")]),t._v(" "),a("p",[t._v("一、（概念作用）ref 是 vue 自带的用来获取 dom 节点的属性。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<input type="text" ref="my-input" />\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.$refs.myInput\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[t._v("#")]),t._v(" nextTick")]),t._v(" "),a("p",[t._v("一、（概念作用）nextTick() 是 vue 自带的用来操作更新后的 dom 节点的方法。")]),t._v(" "),a("p",[t._v("二、（使用场景）比如一个原本隐藏的输入框显示之后立刻需要聚焦，focus() 方法需要写在 nextTick() 方法里面。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<input type="text" ref="my-input" />\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.$nextTick(()=>{\n\tthis.$refs.myInput.focus()\n})\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"scoped"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scoped"}},[t._v("#")]),t._v(" Scoped")]),t._v(" "),a("p",[t._v("一、（概念作用）scoped 是 style 标签的一个属性，加上这个属性之后，样式只会在当前 vue 组件中生效，不会影响其他组件。")]),t._v(" "),a("p",[t._v("二、（作用原理）scoped 的原理是给当前组件内的所有元素添加一个以 data-v 开头的属性，然后匹配属性选择器，进行样式的渲染。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"样式穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#样式穿透"}},[t._v("#")]),t._v(" 样式穿透")]),t._v(" "),a("p",[t._v("一、（作用）为了能修改引入的组件的样式，需要使用样式穿透。")]),t._v(" "),a("p",[t._v("二、（用法）less 和 scss 使用 /deep/ 或者 ::v-deep 关键字，stylus 使用 /deep/ 或者 >>> 进行样式穿透。")]),t._v(" "),a("p",[t._v("less 和 scss：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(".parent /deep/ .child {\n\n}\n.paretn ::v-deep .child {\n\n}\n")])])]),a("p",[t._v("stylus：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(".parent /deep/ .child {\n\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(".parent >>> .child {\n\n}\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"父组件传值到子组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父组件传值到子组件"}},[t._v("#")]),t._v(" 父组件传值到子组件")]),t._v(" "),a("p",[t._v("父组件引入使用子组件，给子组件添加属性值，子组件使用 props 接收传进来的参数，props 可以是数组或者对象形式：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<Child key="value"></Child>\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("{{key}}\n...\nprops: ['key']\nprops: {\n\tkey: String\n}\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"子组件传值到父组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#子组件传值到父组件"}},[t._v("#")]),t._v(" 子组件传值到父组件")]),t._v(" "),a("p",[t._v("子组件使用 this.$emit() 方法，触发自定义的事件，父组件使用子组件，监听自定义的事件并处理：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.$emit('sendValue','value')\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<Child @sendValue="sendValueHandler"></Child>\n...\nmethods: {\n\tsendValueHandler(value){\n\t\t\n\t}\n}\n')])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"兄弟组件之间传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#兄弟组件之间传值"}},[t._v("#")]),t._v(" 兄弟组件之间传值")]),t._v(" "),a("p",[t._v("创建一个空的 vue 对象来做中转站 bus，使用 bus.$emit() 方法来触发自定义事件，使用 bus.$on() 方法来监听自定义事件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import Vue from 'vue'\nexport default new Vue()\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import bus from '@/util/bus.js'\n...\nbus.$emit('sendValue','value')\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import bus from '@/util/bus.js'\n...\nbus.$on('sendValue',value=>{\n\t\n})\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"computed、methods-和-watch-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed、methods-和-watch-的区别"}},[t._v("#")]),t._v(" Computed、methods 和 watch 的区别")]),t._v(" "),a("p",[t._v("一、computed 具有缓存，只有它的依赖发生变化，才会重新计算。methods 没有缓存，每次调用都需要执行一次函数。")]),t._v(" "),a("p",[t._v("二、computed 是根据已有属性进行计算得到的一个新属性，只有已有属性发生变化时重新计算。watch 默认是不返回值的，只有监听的数据发生变化才做出响应，可以在里面发送异步请求。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"props-和-data-的优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props-和-data-的优先级"}},[t._v("#")]),t._v(" props 和 data 的优先级")]),t._v(" "),a("p",[t._v("一、props 的优先级大于 data ，这是在 vue 的源码中规定的。")]),t._v(" "),a("p",[t._v("二、vue 常用属性的优先级比较如下：props > methods > data. > computed > watch。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"vuex-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-属性"}},[t._v("#")]),t._v(" vuex 属性")]),t._v(" "),a("p",[t._v("vuex 是一个用来存储管理 vue 数据的仓库，它的属性包括：")]),t._v(" "),a("ul",[a("li",[t._v("state：主要用来存储值，类似于 vue 中的 data；")]),t._v(" "),a("li",[t._v("getters：根据 state 的值计算出另一个值，类似于 vue 中的 computed；")]),t._v(" "),a("li",[t._v("mutations：主要用来修改 state 中存储的值，类似于 vue 中的 methods；")]),t._v(" "),a("li",[t._v("actions: 主要用来提交 mutations 来修改 state 中存储的值；")]),t._v(" "),a("li",[t._v("modules：模块化，每个模块拥有自己的 state 等属性，然后每个功能对应一个模块，方便维护管理。")])]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"vuex-中-mutations-和-actions-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-中-mutations-和-actions-的区别"}},[t._v("#")]),t._v(" vuex 中 mutations 和 actions 的区别")]),t._v(" "),a("p",[t._v("mutations 和 actions 都可以修改 state 中存储的值，它们的具体区别如下：")]),t._v(" "),a("ul",[a("li",[t._v("mutations 可以直接修改 state 的值，而 actions 通过提交 mutations 来修改 state 的值；")]),t._v(" "),a("li",[t._v("mutations 包含的是同步操作，actions 包含的是异步操作。")])]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"vuex-数据流向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-数据流向"}},[t._v("#")]),t._v(" vuex 数据流向")]),t._v(" "),a("p",[t._v("vuex 是单向数据流，不能直接修改，否则会报错，只能通过 mutations 或者 actions 来修改 state 的值。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"vuex-持久化存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-持久化存储"}},[t._v("#")]),t._v(" vuex 持久化存储")]),t._v(" "),a("p",[t._v("一、vuex 存储的数据一般刷新页面就会重置，因为它本身不能持久化存储。")]),t._v(" "),a("p",[t._v("二、vuex 实现持久化存储：")]),t._v(" "),a("ul",[a("li",[t._v("在保存数据的时候和 localStorage 结合使用；")]),t._v(" "),a("li",[t._v("使用持久化存储插件 vuex-persist，它其实也是使用了本地存储实现的。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 打开 terminal，下载插件\nnpm i vuex-persist\n// 修改 store/index.js 文件，引入插件\nimport VuexPersist from 'vuex-persist'\n// 修改 store/index.js 文件，创建对象\nconst vuexPersist = new VuexPersist({\n\tstorage: window.localStorage\n})\n// 修改 store/index.js 文件，挂载插件：\nconst store = new Vuex.Store({\n\tstate: {...},\n\t...,\n\tplugins: [vuexPersist.plugin]\n})\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"设置代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设置代理"}},[t._v("#")]),t._v(" 设置代理")]),t._v(" "),a("p",[t._v("一、vue 项目解决跨域问题：修改 vue.config.js 文件，在 devServer 的 proxy 里面设置请求路径。")]),t._v(" "),a("p",[t._v("二、vue 项目简单打包之后出现空白页面，是因为代理不生效，请求失败，获取不到数据。")]),t._v(" "),a("p",[t._v("vue.config.js 文件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("module.exports = {\n\t// 公共路径\n\tpublicPath: './',\n\t// 开发服务器\n\tdevServer: {\n\t\t// 代理\n\t\tproxy: 'http://localhost:3000'\n\t}\n}\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"打包步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打包步骤"}},[t._v("#")]),t._v(" 打包步骤")]),t._v(" "),a("p",[t._v("一、将 vue.config.js 文件中的 publicPath 公共路径的值修改为 ./。")]),t._v(" "),a("p",[t._v("二、创建 .env.production 环境变量文件。")]),t._v(" "),a("p",[t._v("三、修改二次封装 axios 的 request.js 文件，如果是生产环境，设置 axios 的 defaults.baseURL 默认请求路径前缀为生产环境的请求路径。")]),t._v(" "),a("p",[t._v("四、修改 router.js 文件，使用 hash 模式打包，本地运行 index.html 进行测试。")]),t._v(" "),a("p",[t._v("五、修改 router.js 文件，使用 history 模式打包，让后台设置 cors 解决跨域问题，让后台重定向。")]),t._v(" "),a("p",[t._v("vue.config.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("module.exports = {\n\tpublicPath: './',\n\t...\n}\n")])])]),a("p",[t._v(".env.production")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n// 项目标题\nVUE_APP_TITLE = '项目标题'\n// 项目环境\nVUE_APP_ENV = 'pro'\n// 项目请求基本路径\nVUE_APP_BASE_API = 'http:///'\n")])])]),a("p",[t._v(".request.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if(process.env.VUE_APP_ENV === 'pro'){\n\taxios.defaults.baseURL = process.env.VUE_APP_BASE_API\n}\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"路由模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由模式"}},[t._v("#")]),t._v(" 路由模式")]),t._v(" "),a("p",[t._v("一、路由模式分为 hash 哈希模式（默认模式）和 history 历史模式，它们的具体区别如下：")]),t._v(" "),a("ul",[a("li",[t._v("（url 形式不同）哈希模式的 url 附带 #，历史模式的 url 是 /；")]),t._v(" "),a("li",[t._v("（是否发送请求）当跳转到 404 找不到的页面时，哈希模式不会发送请求，历史模式会发送请求。")]),t._v(" "),a("li",[t._v("（打包使用不同）打包用于本地测试的时候要使用哈希模式，使用历史模式会出现空白页面。")])]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"spa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spa"}},[t._v("#")]),t._v(" spa")]),t._v(" "),a("p",[t._v("参考文章：")]),t._v(" "),a("p",[t._v("https://blog.csdn.net/qq_43540219/article/details/108754927")]),t._v(" "),a("p",[t._v("spa，single page application ，单页面应用")]),t._v(" "),a("p",[t._v("最主要的两个缺点")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("首次加载消耗开销大，用时长；")])]),t._v(" "),a("li",[a("p",[t._v("不利于 seo 搜索引擎优化，因为打包只生成一个页面，不能加入分别对页面加入描述、标题、关键词。")])])]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"路由传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由传值"}},[t._v("#")]),t._v(" 路由传值")]),t._v(" "),a("p",[t._v("第一种，结合使用 path 和 query 来传值。这是一种显示传值，在 url 上能看到参数，刷新页面之后，参数还是存在的。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.$router.push({\n\tpath: '/path',\n\tquery: {\n\t\tkey: 'value'\n\t}\n})\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.$route.query.key\n")])])]),a("p",[t._v("第二种，结合使用 name 和 params 来传值。这是一种隐式传值，在 url 上不能看到参数，刷新页面之后，参数就消失了。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.$router.push({\n\tname: 'name',\n\tparams: {\n\t\tkey: 'value'\n\t}\n})\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.$route.params.key\n")])])]),a("p",[t._v("第三种，是动态路由匹配传值，在路径的最后拼接上 :key，使用 params 来接收。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("{\n\tpath: '/path/:key'\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this.$route.params.key\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"路由守卫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由守卫"}},[t._v("#")]),t._v(" 路由守卫")]),t._v(" "),a("p",[t._v("参考文章：")]),t._v(" "),a("ul",[a("li",[t._v("https://router.vuejs.org/zh/guide/advanced/navigation-guards.html")])]),t._v(" "),a("p",[t._v("路由守卫可以分为三大类，分别是全局守卫、路由独享的守卫和组件内的守卫。")]),t._v(" "),a("p",[t._v("全局守卫包括：beforeEach 全局前置守卫、beforeResolve 全局解析守卫、afterEach 全局后置守卫。其中 beforeEach 全局前置守卫可以用来做页面的访问控制，比如判断用户登录了才让跳转。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code")])]),a("p",[t._v("路由独享的守卫包括：beforeEnter。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code")])]),a("p",[t._v("组件内的守卫包括：beoferRouteEnter、beforeRouteUpdate、beforeRouteLeave。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n")])])]),a("hr"),t._v(" "),a("h1",{attrs:{id:"seo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#seo"}},[t._v("#")]),t._v(" seo")]),t._v(" "),a("p",[t._v("vue 框架的特点就是单页面应用，它有一个比较大的缺点就是不利于 seo。要做到搜索引擎优化，比较基本的条件是项目要有多个页面，然后页面上要存在被爬虫抓取的文本等内容，每个页面包含自己的标题、关键词和描述。")]),t._v(" "),a("p",[t._v("实现 vue seo 的一种方式是使用预渲染，具体的操作是结合使用 prerender-spa-plugin 和 vue-meta-info 插件。在 prerender-spa-plugin 插件中配置需要预渲染的页面，在每个页面使用 vue-meta-info 插件设置标题、关键词和描述。（预渲染适合于少量页面的 seo，它不能动态地改变页面的标题、关键词和描述。）")]),t._v(" "),a("p",[t._v("修改 vue.config.js 文件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var PrerenderSPAPlugin = require('prerender-spa-plugin')\nvar path = require('path')\nmodule.exports = {\n\t// 公共路径\n\tpublicPath: './',\n\t// 配置 webpack\n\tconfigureWebpack: {\n\t\t// 插件\n\t\tplugins: [\n\t\t\tnew PrerenderSPAPlugin({\n\t\t\t\t// 静态目录\n\t\t\t\tstaticDir: path.join(__dirname,'dist'),\n\t\t\t\t// 路由\n\t\t\t\troutes: [\n\t\t\t\t\t'/',\n\t\t\t\t\t'/about',\n\t\t\t\t\t'contact'\n\t\t\t\t]\n\t\t\t})\n\t\t]\n\t}\n}\n")])])]),a("p",[t._v("修改 main.js 文件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import VueMetaInfo from 'vue-meta-info'\nVue.use(VueMetaInfo)\n")])])]),a("p",[t._v("修改 Demo.vue 文件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default {\n\t// meta 信息\n\tmetaInfo: {\n\t\t// 标题\n\t\ttitle: '标题',\n\t\t// meta\n\t\tmeta: [\n\t\t\t// 关键词\n\t\t\t{\n\t\t\t\tname: 'keywords',\n\t\t\t\tcontent: '关键词'\n\t\t\t},\n\t\t\t// 描述\n\t\t\t{\n\t\t\t\tname: 'description'，\n\t\t\t\tcontent: '描述'\n\t\t\t}\n\t\t]\n\t}\n}\n")])])]),a("p",[t._v("实现 vue seo 的另一种方式是使用服务端渲染(ssr : server slide render)，具体的操作是使用 nuxt.js 开发项目。nuxt 是基于 vue 开发的能够实现 seo 的框架。")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[t._v("#")]),t._v(" mvvm")]),t._v(" "),a("h1",{attrs:{id:"diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" diff 算法")]),t._v(" "),a("p",[t._v("参考文章：")]),t._v(" "),a("p",[t._v("https://www.cnblogs.com/wind-lanyan/p/9061684.html")]),t._v(" "),a("p",[t._v("https://segmentfault.com/a/1190000019961419")]),t._v(" "),a("p",[t._v("diff 算法是用来提升性能的算法。")]),t._v(" "),a("p",[t._v("虚拟 dom，其实就是把 dom 数据化成一个对象。")]),t._v(" "),a("p",[t._v("常见的虚拟 dom 库有： snabbom、virtual-dom。")]),t._v(" "),a("p",[t._v("新老节点替换的规则：")]),t._v(" "),a("p",[t._v("如果新旧节点的节点名称不同，就删除旧节点，创建插入新节点。如果跨层比较，就删除旧节点，创建插入新节点。")]),t._v(" "),a("p",[t._v("如果新旧节点的节点名称相同，可以分为多种情况：")]),t._v(" "),a("p",[t._v("情况一，新节点没有 children 子级，证明新节点是文本节点，直接把旧节点替换成新文本节点。")]),t._v(" "),a("p",[t._v("情况二，新节点具有 children 子级，旧节点没有 children 子级，创建")]),t._v(" "),a("p",[t._v("情况三、新节点具有 children 子级，旧节点也有 children 子级，这是 diff 算法的核心。")]),t._v(" "),a("h1",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);e.default=v.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{660:function(e,t,s){"use strict";s.r(t);var a=s(17),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"es6-新增特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-新增特性"}},[e._v("#")]),e._v(" es6 新增特性")]),e._v(" "),s("ul",[s("li",[e._v("新增了 let 和 const 来声明变量；")]),e._v(" "),s("li",[e._v("新增了模板字符串；")]),e._v(" "),s("li",[e._v("新增了拓展运算符；")]),e._v(" "),s("li",[e._v("新增了解构赋值；")]),e._v(" "),s("li",[e._v("新增了两种数据结构 map 和 set；")]),e._v(" "),s("li",[e._v("新增了一些数组方法：比如 find 和 filter、some 和 every；")]),e._v(" "),s("li",[e._v("新增了箭头函数；")]),e._v(" "),s("li",[e._v("新增了 promise；")])]),e._v(" "),s("hr"),e._v(" "),s("h1",{attrs:{id:"es6-promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-promise"}},[e._v("#")]),e._v(" es6 promise")]),e._v(" "),s("p",[e._v("promise 是异步编程的一种解决方案，可以用来解决回调地狱的问题。")]),e._v(" "),s("p",[e._v("promise 主要有三种状态，一种是 pending 进行中，一种是 fulfilled 或者 resovled 已成功，还有一种是 rejected 已失败。这三种状态的变化途径有两种，一种是从 pending 进行中到 fulfilled 已成功，另外一种是从 pending 进行中到 rejected 已失败。一旦一种状态通过某中途径过渡到另一种状态，就不能再次发生变化了。")]),e._v(" "),s("p",[e._v("promise 解决回调地狱的问题是通过它的实例对象的 then 方法来实现的，这个 then 方法可以链式调用。但是链式调用一旦多了之后，代码就会显得冗余和复杂。所以后面人们通过研究就进化出了 async/await。async/aswit 是异步编程最终的一种解决方案，它是用同步的形式，发送异步的请求，获取数据。")]),e._v(" "),s("p",[e._v("这大概就是我对 promise 和 async/await 的了解。")]),e._v(" "),s("p",[e._v("（promise 常用构造函数的方法有两个，一个是 resolve，主要用来解析结果；一个是 reject，主要用来抛出异常。promise 实例对象常用的方法有两个，一个是 then，主要用来获取结果；一个是 catch，主要用来捕获异常。）")]),e._v(" "),s("p",[e._v("（reject 方法后面的内容，首先会出现在 then 方法的第二个回调函数，然后才出现在 catch 方法。如果断网了，直接出现在 catch 方法里面。）")]),e._v(" "),s("hr"),e._v(" "),s("h1",{attrs:{id:"es6-箭头函数和普通函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-箭头函数和普通函数"}},[e._v("#")]),e._v(" es6 箭头函数和普通函数")]),e._v(" "),s("ul",[s("li",[e._v("（this 指向是否相同）箭头函数的 this 指向是在定义时就决定了的，普通函数的 this 指向在运行时才决定的。（箭头函数的 this 指向和外层第一个普通函数的 this 指向一致。）")]),e._v(" "),s("li",[e._v("（是否能够 new，作为构造参数）箭头函数不能 new ，不能作为构造函数使用；普通函数能够 new，可以作为构造函数使用。")]),e._v(" "),s("li",[e._v("（是否具有 prototype 原型对象）箭头函数没有 prototype 原型，普通函数具有 prototype 原型。")]),e._v(" "),s("li",[e._v("（是否具有 arguments 参数）箭头函数没有 arguments 参数，普通函数没有 arguments 参数。")])]),e._v(" "),s("hr"),e._v(" "),s("h1",{attrs:{id:"es6-var、let-和-const-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-var、let-和-const-的区别"}},[e._v("#")]),e._v(" es6 var、let 和 const 的区别")]),e._v(" "),s("p",[e._v("var、let 和 const 都可以用来声明变量，它们的区别区别如下：")]),e._v(" "),s("ul",[s("li",[e._v("一个是是否会导致变量提升，var 声明变量会导致变量提升，let 和 const 声明变量不会导致变量提升；")]),e._v(" "),s("li",[e._v("一个是是否能够重复声明，var 可以重复声明同一个变量，let 和 const 不能重复声明同一个变量；")]),e._v(" "),s("li",[e._v("一个是是否能够重复赋值，var 和 let 声明的变量可以重复赋值，const 声明变量的时候就需要赋值，是一个常量，不能再次改变；")]),e._v(" "),s("li",[e._v("还有一个是是否具有自身的作用域，var 声明的变量没有自身的作用域，let 和 const 声明的变量具有自身的作用域。")])]),e._v(" "),s("hr"),e._v(" "),s("h1",{attrs:{id:"es6-find-和-filter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-find-和-filter"}},[e._v("#")]),e._v(" es6 find 和 filter")]),e._v(" "),s("ul",[s("li",[e._v("find 方法遍历数组，找到第一个符合条件的元素就退出循环，返回的是一个元素；")]),e._v(" "),s("li",[e._v("filter 方法遍历数组，过滤出所有符合条件的元素，返回的是一个数组。")])]),e._v(" "),s("hr"),e._v(" "),s("h1",{attrs:{id:"es6-some-和-every"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-some-和-every"}},[e._v("#")]),e._v(" es6 some 和 every")]),e._v(" "),s("ul",[s("li",[e._v("some() 方法遍历数组，主要有一个元素满足条件就返回 true，只有全部元素都不满足条件才返回 false；")]),e._v(" "),s("li",[e._v("every() 方法遍历数组，只有全部条件都满足元素才返回 true，只要有一个元素不满足条件才返回 false；")])]),e._v(" "),s("hr"),e._v(" "),s("h1",{attrs:{id:"es6-合并对象方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-合并对象方法"}},[e._v("#")]),e._v(" es6 合并对象方法")]),e._v(" "),s("p",[e._v("可以使用拓展运算符；也可以使用 Object.assign() 方法；另外还可以自己封装一个 merge 函数，遍历 source 对象，把它的每个属性都添加给 target 对象，返回 target 对象。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const obj3 = {...obj1,...obj2}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const obj3 = Object.assign(obj1,obj2)\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function merge(target,source){\n\tfor(let k in source){\n\t\ttarget[k] = source[k]\n\t}\n\treturn target[k]\n}\n")])])]),s("hr"),e._v(" "),s("h1",{attrs:{id:"es6-作用域考题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-作用域考题"}},[e._v("#")]),e._v(" es6 作用域考题")]),e._v(" "),s("p",[e._v("一、var 声明变量会导致变量提升，let 和 const 声明变量不会导致变量提升：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("console.log( str ) //undefined\nvar str = '你好'\nconsole.log( num ) //报错\nlet num = 10\n")])])]),s("p",[e._v("二、var 声明的变量没有自身的作用域，let 和 const 声明的变量具有自身的作用域：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function demo(){\n\tvar n = 2;\n\tif(true){\n\t\tvar n = 1\n\t}\n\tconsole.log(n) //1\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function demo(){\n\tlet n = 2;\n\tif(true){\n\t\tlet n = 1\n\t}\n\tconsole.log(n) //2\n}\n")])])]),s("hr")])}),[],!1,null,null,null);t.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{669:function(t,a,n){"use strict";n.r(a);var e=n(17),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"延迟加载的方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#延迟加载的方式"}},[t._v("#")]),t._v(" 延迟加载的方式")]),t._v(" "),n("ul",[n("li",[t._v("第一种，把 script 标签放在 body 里面的最后。")]),t._v(" "),n("li",[t._v("第二种，给 script 标签加上 async 属性。它会在 html 解析的期间开始下载 js 脚本，等 js 脚本下载完成之后，暂停 html 解析，开始执行 js 脚本。它执行 js 脚本是不按照顺序的，谁先加载完成谁先执行。")]),t._v(" "),n("li",[t._v("第二种，给 script 标签加上 defer 属性。它会在 html 解析的期间开始下载 js 脚本，等 js 脚本下载完成之后，继续等待全部 html 解析完成，之后才开始执行 js 脚本。它执行 js 脚本是按照顺序的，谁先引入谁先执行。")])]),t._v(" "),n("hr"),t._v(" "),n("h1",{attrs:{id:"宏任务、微任务、事件循环"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#宏任务、微任务、事件循环"}},[t._v("#")]),t._v(" 宏任务、微任务、事件循环")]),t._v(" "),n("ul",[n("li",[t._v("js 是一门单线程语言，在同一时间内，只能做一件事情；")]),t._v(" "),n("li",[t._v("js 的任务分为同步任务和异步任务，其中异步任务又包括宏任务和微任务。常见的宏任务包括发送请求、绑定事件、设置定时器和 script 标签里面的代码，常见的微任务包括 Promise.then() 和 this.$nextTick() 方法。")]),t._v(" "),n("li",[t._v("js 一般先执行同步任务，接着执行微任务，然后执行宏任务。")]),t._v(" "),n("li",[t._v("js 执行任务是遵循 event loop 事件循环机制的。所有任务进入到执行栈，判断当前任务是同步任务还是异步任务，同步任务进入主线程，异步任务进行事件列表，区分宏任务还是微任务，注册回调函数之后，放到任务队列中。主线程上，当之前的同步任务执行完成之后，就会去读取任务队列里面的任务，放大主线程上去执行。以上过程将不断重复。")])]),t._v(" "),n("p",[t._v("考题：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("for(let i = 0; i < 3; i++){\n\tsetTimeout(()=>{\n\t\tconsole.log(i)\n\t},i*1000)\n}\n// 3 // 第0秒打印\n// 3 // 第1秒打印\n// 3 // 第2秒打印\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("setTimeout(()=>{ //宏任务1\n\tconsole.log('1') // 宏任务1-同步任务1\n\t\n\tsetTimeout(()=>{\n\t\tconsole.log('2') // 宏任务3（放入宏任务队列，此前队列已经存在未执行的宏任务2）\n\t},0)\n\t\n\tnew Promise(resolve=>{\n\t\tconsole.log('3') //宏任务1-同步任务2\n\t\tresolve()\n\t}).then(()=>{\n\t\tconsole.log('4') //宏任务1-微任务1（放入微任务队列）\n\t})\n\t\n},0)\n\nsetTimeout(()=>{ //宏任务2\n\tconsole.log('5') //宏任务2-同步任务1\n},0)\n\nconsole.log('6') //同步任务\n// 6 1 3 4 5 2\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),n("ul",[n("li",[t._v("我的理解是，闭包是一个函数和创建这个函数的作用域的连接，闭包关闭了函数的自由变量。（自由变量：在当前作用域中使用，在其他作用域中声明的变量。）")]),t._v(" "),n("li",[t._v("内部函数被外部函数返回并且保存起来使用，导致外部函数的作用域不被释放，这样就产生了闭包。")]),t._v(" "),n("li",[t._v("闭包的优点是内部函数可以访问外部函数的局部变量。")]),t._v(" "),n("li",[t._v("闭包的缺点是，变量长期驻留在内存中，会造成内存损耗的问题。为了解决这个问题，可以将被返回的内部函数设置为 null。（另外在 ie 浏览器中，闭包可以造成内存泄漏问题。）")])]),t._v(" "),n("hr"),t._v(" "),n("h1",{attrs:{id:"原型和原型链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),n("ul",[n("li",[t._v("根据我的了解，作者设计原型是为了实现属性和方法的共享。")]),t._v(" "),n("li",[t._v("每个对象都有一个 prototype 属性，它指向对象的原型；每个构造函数都有一个 "),n("code",[t._v("__proto__")]),t._v(" 属性，它指向构造函数的原型对象。（每个对象的原型都有一个 constructor 属性，它指向了构造函数。）")]),t._v(" "),n("li",[t._v("js 查找属性和方法的顺序是：首先到对象里面去查找，如果找不到，就去构造函数里面查找。如果找不到，就去对象的原型里面查找。如果找不到，就去构造函数的原型对象里面查找。如果找不到，就去对象的原型的原型里面查找。这样就形成了一个查找的链条，把它叫做原型链。")]),t._v(" "),n("li",[t._v("原型链的最顶端是 null。")])]),t._v(" "),n("hr"),t._v(" "),n("h1",{attrs:{id:"继承方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继承方式"}},[t._v("#")]),t._v(" 继承方式")]),t._v(" "),n("ul",[n("li",[t._v("有 es6 继承的方式，使用 extends 关键字：")]),t._v(" "),n("li",[t._v("还有原型式继承，声明一个创建子类的普通函数，在普通函数内部，声明一个构造函数，将构造函数的原型对象指向传入的对象，返回构造函数创建的实例：")]),t._v(" "),n("li",[t._v("还有原型链继承，让子级构造函数的原型对象指向父级构造函数的实例：")]),t._v(" "),n("li",[t._v("还有借用构造函数继承，在子级构造函数中引入父级构造函数，可以使用 call 等方法：")]),t._v(" "),n("li",[t._v("还有原型链和借用构造函数的组合继承方式；")]),t._v(" "),n("li",[t._v("另外还有寄生式继承和寄生式组合继承。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Parent {\n\tthis.name = 'z'\n}\nclass Child extends Parent {\n\tconstructor(){\n\t\tsuper()\n\t}\n}\nconst child = new Child()\nconsole.log(child.name)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Parent(){\n\tthis.name = 'z'\n}\nfunction createChild(obj){\n\tfunction Fun(){\t\n\t}\n\tFun.prototype = obj\n\treturn new Fun()\n}\nconst parent = new Parent()\nconst child = createChild(parent)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Parent(){\n\tthis.name = 'z'\n}\nfunction Child(){\t\n}\nChild.prototype = new Parent()\nconst child = new Child()\nconsole.log(child.name)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Parent(){\n\tthis.name = 'z'\n}\nfunction Child(){\t\n\tParent.call(this)\n}\nconst child = new Child()\nconsole.log(child.name)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Parent(){\n\tthis.name = 'z'\n}\nfunction Child(){\t\n\tParent.call(this)\n}\nChild.prototype = new Parent()\nconst child = new Child()\nconsole.log(child.name)\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"call、apply、bind"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#call、apply、bind"}},[t._v("#")]),t._v(" call、apply、bind")]),t._v(" "),n("ul",[n("li",[t._v("call、apply 和 bind 方法都可以用来改变函数的 this 指向。")]),t._v(" "),n("li",[t._v("（非指向参数的形式不同）call 和 bind 方法的非指向参数的形式是一个不定参数，可以传入多个；apply 方法的非指向参数的形式是一个数组，只能传入一个。")]),t._v(" "),n("li",[t._v("call 和 apply 方法执行之后立即调用，bind 方法执行之后返回一个函数，需要再次调用。")])]),t._v(" "),n("hr"),t._v(" "),n("h1",{attrs:{id:"浅拷贝和深拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝和深拷贝"}},[t._v("#")]),t._v(" 浅拷贝和深拷贝")]),t._v(" "),n("ul",[n("li",[t._v("浅拷贝和深拷贝是针对引用数据类型而言的，基本数据类型在堆中存放的是值，引入数据类型在堆中存放的是地址，在栈中存放的才是真正的值。")]),t._v(" "),n("li",[t._v("浅拷贝只是复制了地址，拷贝出来的对象的属性和方法发生变化，原对象也会收到影响；深拷贝是复制真正的值，拷贝出来的对象的属性和方法发生变化，原对象不会收到影响。")]),t._v(" "),n("li",[t._v("浅拷贝经常使用的方法有两种：一种是直接赋值，另一种是使用 Object.assign() 方法；深拷贝经常使用的方法也有两种：一种是结合使用 JSON.stringify() 和 JSON.parse() 方法，另一种是自己封装一个递归函数。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const newObject = object\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const newObject = Object.assign({},object)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const newObject = JSON.parse(JSON.stringify(object))\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function deepCopy(target){\n\t// 声明结果\n\tlet result\n\t// 引用数据类型\n\tif(typeof target === 'object'){\n\t\t// 无\n\t\tif(target === null){\n\t\t\t// 结果赋值为null\n\t\t\tresult = null\n\t\t}\n\t\t// 数组\n\t\telse if(Array.isArray(target)){\n\t\t\t// 结果先赋值为空数组\n\t\t\tresult = []\n\t\t\t// 遍历数组\n\t\t\tfor(let i = 0; i < target.length; i++){\n\t\t\t\t// 深拷贝赋值给结果\n\t\t\t\tresult[i] = deepCopy(target[i])\n\t\t\t}\n\t\t}\n\t\t// 对象\n\t\telse{\n\t\t\t// 结果先赋值为空对象\n\t\t\tresult = []\n\t\t\t// 遍历对象\n\t\t\tfor(let k in target){\n\t\t\t\t// 深拷贝复制给结果\n\t\t\t\tresult[k] = deepCopy(target[k])\n\t\t\t}\n\t\t}\n\t}\n\t// 基本数据类型\n\telse{\n\t\t// 直接赋值给结果\n\t\tresult = target\n\t}\n\t// 返回结果\n\treturn result\n}\nconst newObject = deepCopy(object)\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"localstorage、sessionstorage、cookie"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#localstorage、sessionstorage、cookie"}},[t._v("#")]),t._v(" localStorage、sessionStorage、cookie")]),t._v(" "),n("ul",[n("li",[t._v("localStorage、sessionStorage 和 cookie 都可以用来在客户端存储数据。")]),t._v(" "),n("li",[t._v("存储在 localStorage 中的数据，是持久化存在的，除非手动清除；存储在 sessionStorage 中的数据，在关闭浏览器之后就会消失；存储在 cookie 中的数据，在设置的过期时间之内一致生效。")]),t._v(" "),n("li",[t._v("localStorage 和 sessionStorage 能够存储的容量大约是 5MB，cookie 能够存储的容量大约是 4KB。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("localStorage.setItem('key','value')\nlocalStorage.removeItem('key')\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("sessionStorage.setItem('key','value')\nsessionStorage.removeItem('key')\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("document.cookie=`key=value;expires=${date.toUTCString()}'\ndocument.cookie=''\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"new-操作符具体做了什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-操作符具体做了什么"}},[t._v("#")]),t._v(" new 操作符具体做了什么")]),t._v(" "),n("ul",[n("li",[t._v("（创建对象）第一步，创建一个空的对象；")]),t._v(" "),n("li",[t._v("（指向原型）第二步，将空对象的原型指向构造函数的原型对象；")]),t._v(" "),n("li",[t._v("（改变 this 指向）第三步，改变构造函数的 this 指向，将空对象作为构造函数的执行上下文。")]),t._v(" "),n("li",[t._v("（判断返回值）第四步，判断构造函数执行之后的返回值的数据类型，如果是基本数据类型，则返回空对象，如果是引用数据类型，则返回执行之后的返回值。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function mockNew(Fun,..args){\n\t// 创建对象\n\tconst obj = {}\n\t// 指向原型\n\tObject.setPrototypeOf(obj,Fun.prototype)\n\t// 改变 this 指向\n\tconst result = Fun.apply(obj,args)\n\t// 判断返回值\n\treturn result instanceOf Object ? result : obj\n}\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),n("ul",[n("li",[t._v("数据类型包括基本数据类型和引用数据类型。")]),t._v(" "),n("li",[t._v("其中基本数据类型包括： number 数值型、string 字符串型、boolean 布尔型、undefined 未定义型、 null 空型。")]),t._v(" "),n("li",[t._v("其中引用类型包括：object 对象型。")])]),t._v(" "),n("p",[t._v("考题：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log( true+1 ) // 2 (true转化为1)\nconsole.log( name+1 ) // 'name1' （字符串和任何类型相加，结果都等于字符串）\nconsole.log( undefined+1 ) // NaN （数值类型）\nconsole.log( typeof null ) // 'object'\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log( typeof NaN) // 'number'\nconsole.log(typeof undefined) // 'undefined'\nconsole.log(typeof null) // 'object'\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"null-和-undefined-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-的区别"}},[t._v("#")]),t._v(" null 和 undefined 的区别")]),t._v(" "),n("ul",[n("li",[t._v("作者首先设计了 null ，然后再补充了 undefined。")]),t._v(" "),n("li",[t._v("null 表示“无”的对象，undefined 表示“无”的基本数据类型。")]),t._v(" "),n("li",[t._v("null 转换成数值是 0，undefined 转换成数值是 NaN (not a number) 非数字。")])]),t._v(" "),n("hr"),t._v(" "),n("h1",{attrs:{id:"和-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别"}},[t._v("#")]),t._v(" == 和 === 的区别")]),t._v(" "),n("ul",[n("li",[t._v("== 等于只是比较值；== 全等于不仅比较值，而且比较类型。")]),t._v(" "),n("li",[t._v("不同类型的比较，会进行隐式转换。")])]),t._v(" "),n("p",[t._v("考题：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log( 1 == '1' ) // true（数值类型和字符串类型比较，将字符串类型转为数值类型，将'1'转为1）\nconsole.log( 1 == true) // true（数值类型和布尔类型比较，将布尔类型转为数值类型，将true转为1）\nconsole.log( [1,2] == '1,2' ) //true（引用类型和基本类型比较，将引用类型转为基本类型，将[1,2]转为'1,2'）\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"判断变量是否是数组的方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#判断变量是否是数组的方法"}},[t._v("#")]),t._v(" 判断变量是否是数组的方法")]),t._v(" "),n("p",[t._v("方法一，使用 Array.isArray 方法：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log(Array.isArray([]))\n")])])]),n("p",[t._v("方法二，使用 Array.prototype.isPrototypeOf() 方法：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log(Array.prototype.isPrototypeOf([]))\n")])])]),n("p",[t._v("方法三，判断 constructor.toString() 里面是否包含 Array 字符串：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log([].constructor.toString().includes('Array'))\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"slice-和-splice-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#slice-和-splice-方法"}},[t._v("#")]),t._v(" slice 和 splice 方法")]),t._v(" "),n("p",[t._v("一、slice() 方法：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("该方法用来截取数组元素，返回的是一个包含被截取元素的新数组。")])]),t._v(" "),n("li",[n("p",[t._v("该方法不会影响原数组。")])]),t._v(" "),n("li",[n("p",[t._v("第一个参数 start，开始截取的下标，第二个参数 end，结束截取的下标，截取范围左闭右开。")])]),t._v(" "),n("li",[n("p",[t._v("如果只传入一个开始下标，则从开始下标截取到数组最后一位，包括最后一位。")])]),t._v(" "),n("li",[n("p",[t._v("如果只传入的开始下标是负数，从倒数第几个开始截取到数组最后一位，包括最后一位。")])]),t._v(" "),n("li",[n("p",[t._v("如果开始下标和结束下标都是负数，倒数开始截取，不包括结束的个数。")])])]),t._v(" "),n("p",[t._v("二、splice() 方法")]),t._v(" "),n("ul",[n("li",[t._v("该方法用来添加或者删除数组元素，如果添加元素，返回一个新的空数组，如果删除元素，返回的是一个包含被删除元素的新数组。")]),t._v(" "),n("li",[t._v("该方法会影响原数组。")]),t._v(" "),n("li",[t._v("第一个参数 index ，开始操作的索引；第二个参数 number ，要删除的元素数量，后面是不定参数，依次传入要添加的元素。")])]),t._v(" "),n("hr"),t._v(" "),n("h1",{attrs:{id:"数组去重方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组去重方法"}},[t._v("#")]),t._v(" 数组去重方法")]),t._v(" "),n("p",[t._v("一、使用 Set 数据结构和 Array.from() 方法：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const newArray = Array.from(new Set(array))\n")])])]),n("p",[t._v("二、遍历数组，使用 inlcudes() 方法判断新数组中是否存在当前元素：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const newArray = []\narray.forEach(value=>{\n\tif(!newArray.includes(vavlue)){\n\t\tnewArray.push(value)\n\t}\n})\n")])])]),n("p",[t._v("三、先使用 sort() 方法将数组排好序，再遍历数组，判断前一个元素是否和后一个元素相等：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const newArray = []\nconst a = array.sort()\nnewArray.push(a[0])\nfor(let i = 1; i < a.length; i++){\n\tif(a[i] !== a[i-1]){\n\t\tnewArray.push(a[i])\n\t}\n}\n")])])]),n("ul",[n("li",[t._v("注意 a[-1] === undefined")])]),t._v(" "),n("hr"),t._v(" "),n("h1",{attrs:{id:"防抖和节流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#防抖和节流"}},[t._v("#")]),t._v(" 防抖和节流")]),t._v(" "),n("p",[t._v("一、参考文章：")]),t._v(" "),n("ul",[n("li",[t._v("https://blog.csdn.net/zuorishu/article/details/93630578")])]),t._v(" "),n("p",[t._v("二、防抖：触发事件，延迟一定时间后再执行函数；如果这段时间内再次触发函数，则重新开始计时，最后才执行一次。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function debounce(fun,delay){\n\t// 声明定时器\n\tlet timer\n\t// 声明内部函数\n\treturn function(){\n\t\t// 如果已经设置了定时器\n\t\tif(timer){\n\t\t\t// 清除定时器\n\t\t\twindow.clearTimeout(timer)\n\t\t}\n\t\t// 重新开始计时\n\t\ttimer = window.setTimeout(fun,delay)\n\t}\n}\n")])])]),n("p",[t._v("三、节流：触发事件，延迟一定时间后执行函数；如果这段时间内再次触发函数，直接退出。保证一定时间内只能执行一次函数，间隔多次。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function throttle(){\n\t// 打开开关\n\tlet flag = true\n\t// 声明内部函数 \n\treturn function(fun,delay){\n\t\t// 如果开关关闭\n\t\tif(!flag){\n\t\t\t// 直接返回\n\t\t\treturn\n\t\t}\n\t\t// 关闭开关\n\t\tflag = false\n\t\t// 设置定时器\n\t\twindow.setTimeout(()=>{\n\t\t\t// 执行函数\n\t\t\tfun()\n\t\t\t// 打开开关\n\t\t\tflag = true\n\t\t},delay)\n\t}\n}\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"预编译"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#预编译"}},[t._v("#")]),t._v(" 预编译")]),t._v(" "),n("p",[t._v("参考文章：")]),t._v(" "),n("p",[t._v("https://zhuanlan.zhihu.com/p/483283900")]),t._v(" "),n("p",[t._v("概念：")]),t._v(" "),n("p",[t._v("预编译是做一些代码文本的替换工作，是整个编译过程最先做的工作。")]),t._v(" "),n("p",[t._v("过程：")]),t._v(" "),n("p",[t._v("预编译在全局执行开始之前，首先会创建一个 GO 对象。GO 全称 Global Object，全局对象，也可以叫做全局执行期上下文。在创建完 GO 对象之后，会继续执行以下步骤：第一步，寻找变量的声明，找到之后把它放入 GO 里面，并且赋值为 undefined；第二步，寻找函数的声明，并且赋值函数体。第三部，执行全局。")]),t._v(" "),n("p",[t._v("预编译在函数执行开始之前，首先会创建一个 AO 对象。AO 全称 Activation Object，活跃对象，也可以叫做函数执行期上下文。在创建完 AO 对象之后，会继续执行以下步骤：第一步，寻找函数的形参和变量的声明，找到之后把它们放入 AO 里面，并且赋值为 undefined；第二步，把实参赋值给形参；第三步，寻找函数的声明，并且赋值函数体；第四步，执行函数。")]),t._v(" "),n("p",[t._v("注意预编译阶段做过的事情，在函数执行之前不会再做，只会做没做过的事情。")]),t._v(" "),n("p",[t._v("案例：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var b = 1;\nconsole.log(a)\nfunction a(a){\n\tconsole.log(a)\n\tvar a = 2\n\tconsole.log(a)\n\tfunction a(){}\n\tvar b = 3\n\tconsole.log(b)\n}\na(0)\n")])])]),n("p",[t._v("步骤：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("go = {\n\tb: undefined;\n} \n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("go = {\n\tb: undefined;\n\ta: function a(a) {};\n} \n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("go = {\n\tb: undefined - 1;\n\ta: function(a) {};\n}\nao = {\n\ta: undefined;\n\tb: undefined;\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("go = {\n\tb: undefined - 1;\n\ta: function(a) {};\n}\nao = {\n\ta: undefined - 0;\n\tb: undefined;\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("go = {\n\tb: undefined - 1;\n\ta: function(a) {};\n}\nao = {\n\ta: undefined - 0 - function a(){};\n\tb: undefined;\n}\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"找出二维数组中每组的最大值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#找出二维数组中每组的最大值"}},[t._v("#")]),t._v(" 找出二维数组中每组的最大值")]),t._v(" "),n("p",[t._v("遍历二维数组，使用 Math.max() 方法找出当前数组的最大值：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const newArray = []\ndoubleArray.forEach(array=>{\n\tnewArray.push(Math.max(...array))\n})\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"找出多维数组的最大值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#找出多维数组的最大值"}},[t._v("#")]),t._v(" 找出多维数组的最大值")]),t._v(" "),n("p",[t._v("首先使用 join() 方法将多维数组连接成一个字符串，再使用 split() 方法将字符串分割成一个一维数组，最后使用 Math.max() 方法找出最大值：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const newArray = array.join(',').split(',')\nconst maxValue = Math.max(...newArray)\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"给字符串新增方法实现功能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给字符串新增方法实现功能"}},[t._v("#")]),t._v(" 给字符串新增方法实现功能")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("String.prototype.addPrefix = function(str){\n\treturn str + this\n}\nconsole.log( 'world'+addPrefix('hello') )\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"找出字符串中出现次数最多的字符以及个数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#找出字符串中出现次数最多的字符以及个数"}},[t._v("#")]),t._v(" 找出字符串中出现次数最多的字符以及个数")]),t._v(" "),n("p",[t._v("创建一个空对象来做map，遍历字符串，如果当前字符在空对象中存在，计数+1；否则，计数为1：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const str = ''\nconst obj = {}\nfor(let i = 0; i < str.length; i++){\n\tlet c = str[i]\n\tif(obj[c]){\n\t\tobj[c] += 1\n\t}else{\n\t\tobj[c] = 1\n\t}\n}\nlet maxChar = ''\nlet maxCount = 0\nfor(let k in obj){\n\tlet count = obj[k]\n\tif(count > maxCount){\n\t\tmaxChar = k\n\t\tmaxCount = count\n\t}\n}\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"作用域考题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域考题"}},[t._v("#")]),t._v(" 作用域考题")]),t._v(" "),n("p",[t._v("在 es6 之前，js 是没有块级作用域的，只有全局作用域和函数作用域。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("if(true){\n\tvar v = 1\n}\nconsole.log(v) // 1\n")])])]),n("p",[t._v("没有使用 var 声明的变量是全局变量。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("(function(){\n\tvar a = b = 10 // 相当于 var a; b = 10; a 是一个函数变量，b 是一个全局变量。\n})()\nconsole.log(a) // 报错\nconsole.log(b) // 10\n")])])]),n("p",[t._v("var 具有变量提升的机制。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log(a) //undefined\nif(false){\n var a = 10\n}\n// 没有块级作用域，变量提升，但是不赋值\n")])])]),n("p",[t._v("内部可以访问外部的变量，反之不成立。如果内部和外部都有相同命令的变量，优先使用内部的变量。")]),t._v(" "),n("p",[t._v("作用域的优先级：声明赋值变量 > 声明普通函数 > 参数 > 变量提升。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function fun(a){\n\tvar a = 10\n\tfunction a(){\n\t\n\t}\n\tconsole.log(a)\n}\nfun(100) // 10\n")])])]),n("p",[t._v("考题：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function c(){\n\tvar b = 1\n\tfunction a(){\n\t\tconsole.log(b)\n\t\tvar b = 2\n\t\tconsole.log(b)\n\t}\n\ta()\n\tconsole.log(b)\n}\nc()\n// undefined\n// 2\n// 1\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var name = 'a'\n(function(){\n\tif(typeof name == 'undefined'){\n\t\tvar name = 'b'\n\t\tconsole.log('111'+name)\n\t}else{\n\t\tconsole.log('222'+name)\n\t}\n})()\n// 111b\n// 没有块级作用域，name 变量提升\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"对象考题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对象考题"}},[t._v("#")]),t._v(" 对象考题")]),t._v(" "),n("p",[t._v("两个值相等的对象，如果引用地址不相等，它们不是同一个对象。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log( [1,2,3] === [1,2,3] ) // false\ncosnt a = [1,2,3]\nconst na = a\nconsole.log( a === na ) // true\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var obj1 = {\n\ta: 'hellow'\n}\nvar obj2 = obj1\nobj2.a = 'world'\nconsole.log( obj1 ) // {a:'hellow'}\n")])])]),n("p",[t._v("对象的 key 都是字符串类型 'Object object'，所以用对象做 key 会覆盖。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var a = {}\nvar b = {\n\tkey: 'a'\n}\nvar c = {\n\tkey: 'c'\n}\na[b] = '123' // a['Object object'] = '123'\na[c] = '456' //a['Object object'] = '456'\nconsole.log( a[b] ) // '456'\n")])])]),n("p",[t._v("对象查找属性的顺序：首先到对象本身去找，如果找不到，到构造函数去找。如果找不到，去对象的原型去找。如果找不到，去构造函数的原型去找。如果找不到，到对象的原型的原型去找。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Fun(){\n\tthis.a = '这是构造函数的a'\n}\nFun.prototype.a = '这是构造函数原型对象的a'\nconst obj = new Fun()\nobj.a = '这是对象的a'\nobj.__proto__.a = '这是对象的原型的a'\nconsole.log( obj.a ) // '这是对象的a'\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:"作用域-this-指向-原型-考题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域-this-指向-原型-考题"}},[t._v("#")]),t._v(" 作用域 + this 指向 + 原型 考题")]),t._v(" "),n("p",[t._v("定义在构造函数里面this的属性和定义在构造函数体上的属性是不同的。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Foo(){\n\tgetName = function(){console.log(1)}  //没有加this，定义在全局上，普通函数\n\treturn this\n}\nFoo.getName = function(){console.log(2)} //定义在函数体上\nFoo.prototype.getName = function(){console.log(3)} //定义在构造函数的原型对象上\nvar getName = function(){console.log(4)} //定义在全局上，声明式函数\nfunction getName(){ //定义在全局上，普通函数\n\tfunction(){console.log(5)}\n}\nFoo.getName() // 2，寻找定义在构造函数上的\ngetName() // 4，Foo()还未执行，声明式函数大于普通函数\nFoo().getName() //1 ，Foo()执行了，返回this指向 window，寻找定义在全局上的函数，getName = function(){console.log(1)}\ngetName() // 1\nnew Foo().getName() //3 ，new Foo()，返回this指向对象，寻找定义在对象上的函数，找不到，寻找定义在构造函数中的，找不到，\n")])])]),n("p",[t._v("谁执行函数，this 指向谁：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var o = {\n\ta: 10,\n\tb: {\n\t\ta: 2,\n\t\tfn: function(){\n\t\t\tconsole.log(this.a)\n\t\t\tconsole.log(this)\n\t\t}\n\t}\n}\no.b.fn()\n// 此时fn指向b\n// 2\n// { fn: function(){...}}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("window.name = 'ByteDance'\nfunction A(){\n\tthis.name = '123'\n}\nA.prototype.getA = function(){\n\tconsole.log(this)\n\treturn this.name + 1\n}\nlet a = new A()\nlet funcA = a.getA //本身没有，构造函数里面没有，构造函数的原型有\nfuncA() //在window上执行，执行函数内的this指向window\n// window: {}\n// ByteDance1\n// 如果this指向a，返回 a:{} ，return this.name+1被忽略，因为是基本数据类型。\n")])])]),n("p",[t._v("闭包函数的this永远指向window。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var length = 10\nfunction fn(){\n\treturn this.length + 1\n}\nvar obj = {\n\tlength: 5,\n\ttest1: function(){\n\t\treturn fn();\n\t}\n}\nobj.test2 = fn() //  obj.test2 = fn(){return this.length+1}\nconsole.log( obj.test1() ) // 11，闭包中内部函数的this指向为window\nconsole.log( fn() === obj.test2() ) // false, 11 不等于 6 \nconsole.log( obj.test1() == obj.test2() ) // false, 11 不等于 6\n")])])]),n("hr"),t._v(" "),n("h1",{attrs:{id:""}},[n("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);a.default=s.exports}}]);
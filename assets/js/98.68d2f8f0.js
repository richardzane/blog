(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{667:function(e,t,r){"use strict";r.r(t);var s=r(17),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"注册"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#注册"}},[e._v("#")]),e._v(" 注册")]),e._v(" "),r("p",[e._v("注册，有账号密码和和手机号短信验证码两种方式，在这里我介绍一下手机号短信验证码这种方式。用户点击“注册”按钮，弹出一个注册的窗口，要求用户输入手机号和短信验证码。用户输入手机号，点击“获取短信验证码”的按钮。拿到用户输入的手机号，用正则表达式去校验它的格式。校验通过，弹出一个行为验证的窗口，要求用户在给出的图片中按顺序识别和点击文字。这里说的行为验证主要用到了一个 verifiction 插件，它可以防止别人频繁地获取短信验证码。行为验证通过，在插件的成功回调函数 success 里面，首先关闭行为验证的窗口，拿到验证成功的 code ，然后把手机号作为参数，向后台发送请求，获取短信验证码。同时设置一个 interval 定时器，用来做 60s 倒计时。再设置一个 timeout 定时器，60s 之后清除刚才设置的 interval 定时器，用来重置“获取短信验证码”这个按钮。用户手机收到短信验证码，在表单中输入短信验证码，勾选“同意注册”的复选框，点击“注册”的按钮。再次校验手机号的格式，校验成功，开始对手机号进行加密，这里的加密主要用到了 crypto-js 插件提供的 encrypt() 方法。把加密过后的手机号、短信验证和验证成功的 code 作为参数，向后台发送注册的请求。请求成功，关闭注册的窗口，弹出“注册成功”的提示消息。这大概就是整个注册功能的实现步骤。")]),e._v(" "),r("hr"),e._v(" "),r("h1",{attrs:{id:"登录"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#登录"}},[e._v("#")]),e._v(" 登录")]),e._v(" "),r("p",[e._v("登录和注册一样，有账号密码和和手机号短信验证码两种方式，在这里我介绍一下手机号和短信验证码这种方式。用户点击“登录”按钮，弹出一个登录的窗口，要求用户输入手机号和短信验证码。用户输入手机号，点击“获取短信验证码”的按钮。拿到用户输入的手机号，用正则表达式去校验它的格式。校验通过，弹出一个行为验证的窗口。这里的行为验证主要用到了一个 verifiction 插件，它可以防止别人频繁地获取短信验证码。行为验证通过，在插件的成功回调函数 success 里面，首先关闭行为验证的窗口，拿到验证成功的 code，然后把手机号作为参数，向后台发送获取短信验证码的请求。同时设置一个 interval 定时器，用来做 60s 倒计时，再设置一个 timeout 定时器，60s 之后清除刚才设置的 interval 定时器，用来重置“获取短信验证码”的按钮。用户手机收到短信验证码，在表单中输入短信验证码，点击“登录”的按钮。再次校验手机号的格式，校验通过，开始对手机号进行加密，这里的加密主要用到了 crypto-js 插件提供的 encrypt() 方法。把加密过后的手机号、短信验证码和验证成功的 code 作为参数，向后台发送登录请求。请求成功，后台会返回一个 token，把 token 加密之后保存到 localStorage 中。再次向后台发送请求，获取当前登录用户的信息，将返回的用户信息保存到 vuex 中。关闭登录窗口，弹出“登录成功”的提示消息。这大概就是整个登录功能的实现步骤。")]),e._v(" "),r("hr"),e._v(" "),r("h1",{attrs:{id:"购物车选择课程-单选、取消单选、全选、全都不选、计算总价和总数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#购物车选择课程-单选、取消单选、全选、全都不选、计算总价和总数"}},[e._v("#")]),e._v(" 购物车选择课程（单选、取消单选、全选、全都不选、计算总价和总数）")]),e._v(" "),r("p",[e._v("进入购物车页面，一开始向后台发送请求，获取到购物车课程列表。遍历这个购物车课程列表，给每门课程对象都添加一个 isChecked 属性，表示是否选中当前课程。把全部 isChecked 属性的值都设置为 true，表示默认全部选中。在模板中遍历课程列表的时候，使用 v-model 给每门课程的单选框绑定这个 isChecked 属性，这样就实现了单选和取消单选的功能。")]),e._v(" "),r("p",[e._v("在 computed 计算属性里面定义一个 isAllChecked 属性，表示是否选中全部课程。在 isAllChecked 属性的 get() 方法里面，遍历购物车课程列表，判断每门课程对象的 isChecked 属性的值，只有全部为 true 才返回 true，否则返回 false。这里可以使用数组的 every() 方法。在 isAllChecked 属性的 set() 方法里面，首先获取到当前全选的状态值，遍历购物车课程列表，把当前全选的状态值赋值给每门课程的 isChecked 属性。在模板中渲染的时候，使用 v-model 给全选框绑定上 isAllChecked 属性值，这样就实现了全选和全都不选的功能，并且单选会影响全选，全选也会影响单选。")]),e._v(" "),r("p",[e._v("在 computed 计算属性里面定义一个 totalPrice 属性，表示总价。在方法里面，遍历购物车课程列表，累加选中的课程的价格，然后返回，这样就实现了计算总价的功能。总数和总价的做法类似。")]),e._v(" "),r("hr"),e._v(" "),r("h1",{attrs:{id:"购买课程-去结算、确认订单、完成支付"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#购买课程-去结算、确认订单、完成支付"}},[e._v("#")]),e._v(" 购买课程（去结算、确认订单、完成支付）")]),e._v(" "),r("p",[e._v("用户选中购物车的几门课程，点击“去结算”的按钮。首先创建一个结算数组，遍历购物车课程列表，每门选中的课程对应创建一个结算对象，用来记录课程的 id 和数量，把这些结算对象都 push 到结算数组中。把结算数组保存到 localStorage 中，跳转到确认订单页面。")]),e._v(" "),r("p",[e._v("进入确认订单页面，把刚才的结算数组从本地中拿出来，作为参数，向后台发送去结算的请求。请求成功，后台会返回课程列表、课程总价和支付方式等数据，将这些数据渲染到当前页面中。这里的支付方式包括微信支付和二维码支付。")]),e._v(" "),r("p",[e._v("用户选中某中支付方式，点击“确认订单”的按钮。首先拿到当前的支付方式，把刚才的结算数组和支付方式的 code 作为参数，向后台发送确认订单的请求。请求成功，后台会返回一个订单号和一个支付二维码图片的 url。这个时候弹出二维码支付窗口，等待用户扫码支付。同时设置一个定时器，间断向后台发送请求，用订单号查询当前订单的状态，2s 查询一次。当查询到当前订单已经支付成功的时候，首先清除定时器，然后向后台发送请求，删除购物车中刚刚购买的课程，关闭二维码支付窗口，弹出“支付成功”的提示消息，1s 之后跳转到我的订单页面。注意刚才设置的定时器，如果用户没有完成支付，直接关闭二维码支付窗口，需要清除定时器；如果用户离开当前页面，也需要清除定时器。这大概就是整个购买课程功能的实现步骤。")]),e._v(" "),r("hr"),e._v(" "),r("h1",{attrs:{id:"学习课程-播放视频、设置和恢复历史播放记录"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#学习课程-播放视频、设置和恢复历史播放记录"}},[e._v("#")]),e._v(" 学习课程（播放视频、设置和恢复历史播放记录）")]),e._v(" "),r("p",[e._v("学习课程主要是通过使用 vue-video-player 插件来实现的。这个插件本身已经封装了很多方便的功能，比如设置播放倍速、快进和快退等等。然后它还提供了很多常用的属性和事件，比如 options 属性，就是配置选项；read 事件，就是视频加载完成准备就绪事件；timeupdate 事件，就是视频播放过程时间更新事件。利用这些属性和事件，可以满足一些自定义的需求。")]),e._v(" "),r("p",[e._v("播放视频主要是使用插件提供的 options 里面的 sources 属性，就是资源数组。一开始进入播放视频页面的时候，把课程 id 和课程小节 id 作为参数，向后台发送请求，获取到关于播放课程的数据，这些数据其中就包括一个视频地址 url。首先创建一个资源对象，它包含两个属性。一个是 type 属性，表示视频格式，一般设置它的值为 mp4；另一个是 src 属性，表示视频地址，将刚才获取到的视频地址 url 赋值给 src。然后把资源对象 push 到资源数组中。这样的话只要视频地址正确，视频加载完成就会出现一个播放按钮，点击按钮即可开始播放。这大概就是整个功能的实现步骤。")]),e._v(" "),r("p",[e._v("设置和恢复历史播放记录主要是使用插件提供的 timeupdate 和 ready 事件。给 timeupdate 事件绑定函数，在函数里面，首先设置一个计数器，当计数器累加到某个数值时，比如累加到20，使用插件的 player.cache_.currentTime 属性获取到视频当前的播放秒数。把课程 id 、课程小节 id 和视频当前的播放秒数作为参数，向后台发送请求，设置历史播放记录；给 ready 事件绑定函数，在函数里面，把课程 id 和课程小节 id 作为参数，向后台发送获取上次播放时间的请求。请求成功，获取到上次播放的秒数。使用插件的 player.currentTime() 方法将上次播放秒数设置为视频当前的播放时间。这大概就是整个功能的实现步骤。")]),e._v(" "),r("hr"),e._v(" "),r("h1",{attrs:{id:"控制某些页面登录才能访问"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#控制某些页面登录才能访问"}},[e._v("#")]),e._v(" 控制某些页面登录才能访问")]),e._v(" "),r("p",[e._v("这个功能主要是通过添加 meta 对象和使用路由守卫来实现的。需要去修改 route.js ，路由配置文件。首先给每个需要登录才能访问的路由都添加一个 meta 对象，这个对象包含一个 isNeedLogin 属性，它的值为 true，表示需要登录。然后使用 route.beforeEach() 这个方法，就是全局前置守卫，它有三个参数，分别是 to、from 和 next。每次访问页面之前，判断当前 to 参数里面的 meta 对象里面的 isNeedLogin 属性。如果 isNeedLogin 不存在，或者存在但是它的值不是 true，说明不需要登录，直接使用 next() 方法放行；如果 isNeedLogin 存在，并且它的值为 true，说明需要用户登录。首先判断 localStorage 中的 token 是否存在，如果 token 不存在，说明用户没有登录，使用 route.push() 方法跳转到登录页面；如果 token 存在，说明用户已经登录，直接使用 next() 方法放行。 这大概就是整个功能的实现过程。")]),e._v(" "),r("hr")])}),[],!1,null,null,null);t.default=a.exports}}]);
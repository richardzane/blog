(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{688:function(e,t,a){"use strict";a.r(t);var v=a(17),r=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vue-中的-data-为什么是一个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的-data-为什么是一个函数"}},[e._v("#")]),e._v(" vue 中的 data 为什么是一个函数")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"vue-数据双向绑定的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-数据双向绑定的原理"}},[e._v("#")]),e._v(" vue 数据双向绑定的原理")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"vue-生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[e._v("#")]),e._v(" vue 生命周期")]),e._v(" "),a("p",[e._v("vue 实例从开始创建、初始化数据、编译模板、挂载、更新到销毁等一系列的过程，叫做 vue 的生命周期。")]),e._v(" "),a("p",[e._v("vue 的生命周期的钩子函数包括四大类，分别是创建类、挂载类、更新类和销毁类。创建类，一个是 beforeCreate，创建前，另一个是 created 创建后，在这个阶段可以访问 data 数据了；挂载类，一个是 beforeMount 挂载前，另一个是 mounted 挂载后，在这个阶段已经挂载了 el 根节点了；更新类，一个是 beforeUpdate 更新前，另一个是 updated 更新后；销毁类，一个是 beforeDestroy 销毁前，另一个是 destroyed 销毁后。另外如果使用了 keep-alive 组件，会多出两个钩子函数，一个是 activated 激活，另一个是 deactivated 失效。（如果在 mounted 里面向后台发送请求，可能造成闪屏问题。）")]),e._v(" "),a("p",[e._v("进入组件，会依次执行 beforeCreate、created、beforeMount、mounted 等钩子函数。")]),e._v(" "),a("p",[e._v("使用 keep-alive 缓存的组件，首次进入，会依次执行 beforeCreate、created、beforeMount、mounted、activated 等钩子函数；再次进入，只会执行 activated 钩子函数。")]),e._v(" "),a("p",[e._v("父子组件钩子函数的执行顺序是：父组件的 beforeCreate、created、beforeMount，子组件的 beforeCreate、created、beforeMount、mounted，最后是父组件的 mounted。")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[e._v("#")]),e._v(" keep-alive")]),e._v(" "),a("p",[e._v("keep-alive 是 vue 提供的一个系统组件，可以用来缓存常用的组件。")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"v-if-和-v-show"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show"}},[e._v("#")]),e._v(" v-if 和 v-show")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"v-for-和-v-if-优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-for-和-v-if-优先级"}},[e._v("#")]),e._v(" v-for 和 v-if 优先级")]),e._v(" "),a("p",[e._v("v-for 的优先级大于 v-if，这是在 vue 的源码中的 genElement 生成元素的函数规定的。通常不建议在一个元素上同时使用 v-for 和 v-if，程序会报错。")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"vue-nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-nexttick"}},[e._v("#")]),e._v(" vue nextTick")]),e._v(" "),a("ul",[a("li",[e._v("参考文章：https://zhuanlan.zhihu.com/p/387645539")])]),e._v(" "),a("p",[e._v("nextTick 在下次 dom 更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，可以获取到更新后的 dom 节点。")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"vue-scoped-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-scoped-原理"}},[e._v("#")]),e._v(" vue scoped 原理")]),e._v(" "),a("p",[e._v("scoped 的原理是给当前组件的模板内的所有元素都添加一个以 data-v 开头的属性，然后使用属性选择器选中这些元素，渲染样式。")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"vue-样式穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-样式穿透"}},[e._v("#")]),e._v(" vue 样式穿透")]),e._v(" "),a("p",[e._v("less 和 sass 的样式穿透，可以使用 /deep/ 或者 ::v-deep 关键字；stylus 的样式穿透可以使用 /deep/ 或者 >>> 关键字。")]),e._v(" "),a("p",[e._v("less 和 scss：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(".parent /deep/ .child {\n\n}\n.paretn ::v-deep .child {\n\n}\n")])])]),a("p",[e._v("stylus：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(".parent /deep/ .child {\n\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(".parent >>> .child {\n\n}\n")])])]),a("hr"),e._v(" "),a("h1",{attrs:{id:"vue-组件传值-组件通讯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件传值-组件通讯"}},[e._v("#")]),e._v(" vue 组件传值（组件通讯）")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("父组件传值给子组件：父组件在引入子组件的时候，给子组件加上参数属性。子组件使用 props 属性接收传过来的参数。这个 props 可以是数组或者对象形式。")])]),e._v(" "),a("li",[a("p",[e._v("子组件传值给父组件：子组件使用 $emit 方法触发自定义事件，传递参数，父组件在引入子组件的时候，监听这个自定义事件，绑定对应的处理函数，在函数里面接收传过来的参数。")])]),e._v(" "),a("li",[a("p",[e._v("兄弟组件之间传值：创建一个空的 vue 对象，")])]),e._v(" "),a("li",[a("p",[e._v("还可以使用 vuex 进行传值。")])])]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"computed、methods-和-watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed、methods-和-watch"}},[e._v("#")]),e._v(" computed、methods 和 watch")]),e._v(" "),a("p",[e._v("computed 计算属性是具有缓存的，只有它的依赖项发生改变，才会重新计算。")]),e._v(" "),a("p",[e._v("methods 方法是没有缓存的，每次调用都需要重新执行。")]),e._v(" "),a("p",[e._v("watch 默认是不返回值的，只有数据发生变化的时候才会。")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"vue-数据双向绑定的原理-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-数据双向绑定的原理-2"}},[e._v("#")]),e._v(" vue 数据双向绑定的原理")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])])])}),[],!1,null,null,null);t.default=r.exports}}]);